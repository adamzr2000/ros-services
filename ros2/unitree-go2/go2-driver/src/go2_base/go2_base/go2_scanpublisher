#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Software License Agreement (BSD)
#
# @author    Salman Omar Sohail <support@mybotshop.de>
# @copyright (c) 2024, MYBOTSHOP GmbH, Inc., All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of MYBOTSHOP GmbH nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Redistribution and use in source and binary forms, with or without
# modification, is not permitted without the express permission
# of MYBOTSHOP GmbH.

import math
import rclpy
import threading

from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from sensor_msgs.msg import PointCloud2
from tf2_ros import Buffer, TransformListener, TransformException
from go2_base.utils.tf_cloud import do_transform_cloud
from go2_base.utils.point_cloud2 import read_points

class PointCloudToLaserScanNode(Node):
    def __init__(self):
        super().__init__('go2_scanpublisher')

        # Declare params
        self.declare_parameters(namespace='', parameters=[('target_frame','lidar_link'),
                                                          ('transform_tolerance',0.01),
                                                          ('min_height',0.1),
                                                          ('max_height',0.3),
                                                          ('angle_min',-math.pi/2),
                                                          ('angle_max',math.pi/2),
                                                          ('angle_increment',0.01),
                                                          ('scan_time',0.005),
                                                          ('range_min',0.0),
                                                          ('range_max',10.0),
                                                          ('inf_epsilon',1.0),
                                                          ('use_inf',True),
                                                          ('point_clouds_combine',5),
                                                          ('scan_pub','/go2/scan'),
                                                          ('pcd_sub','/utlidar/cloud_deskewed'),
                                                          ('publisher_frequency', 10)])
        # Get params
        self.target_frame       = self.get_parameter('target_frame').value
        self.tolerance          = self.get_parameter('transform_tolerance').value
        self.min_height         = self.get_parameter('min_height').value
        self.max_height         = self.get_parameter('max_height').value
        self.angle_min          = self.get_parameter('angle_min').value
        self.angle_max          = self.get_parameter('angle_max').value
        self.angle_increment    = self.get_parameter('angle_increment').value
        self.scan_time          = self.get_parameter('scan_time').value
        self.range_min          = self.get_parameter('range_min').value
        self.range_max          = self.get_parameter('range_max').value
        self.inf_epsilon        = self.get_parameter('inf_epsilon').value
        self.use_inf            = self.get_parameter('use_inf').value
        self.number_of_clouds   = self.get_parameter('point_clouds_combine').value
        self.scan_topic         = self.get_parameter('scan_pub').value
        self.pcd_topic          = self.get_parameter('pcd_sub').value
        self.publisher_freq     = self.get_parameter('publisher_frequency').value

        # Variables
        self.last_point_clouds = []
        self.rate = self.create_rate(self.publisher_freq) 

        # Publisher/Subscribers
        self.pub_scan = self.create_publisher(LaserScan, self.scan_topic, 10)
        self.sub_lidar = self.create_subscription(PointCloud2, self.pcd_topic, self.cloud_callback, 10)
    
        self.tf_buffer = Buffer(self.get_clock().now().to_msg())
        self.tf_listener = TransformListener(self.tf_buffer, self)
    
    def colorize(self, text, color):
        color_codes = {
            'green': '\033[92m',
            'yellow': '\033[93m',
            'orange': '\033[38;5;208m', 
            'blue': '\033[94m',
            'red': '\033[91m'
        }
        return color_codes[color] + text + '\033[0m'

    def cloud_callback(self, msg):
        # Append the current point cloud to the list
        self.last_point_clouds.append(msg)

        # Keep only the last 5 point clouds
        self.last_point_clouds = self.last_point_clouds[-self.number_of_clouds:]

    def update_scan(self):
        # build laserscan output
        scan_msg = LaserScan()
        scan_msg.header.stamp = self.get_clock().now().to_msg()
        scan_msg.header.frame_id = self.target_frame
        scan_msg.angle_min = self.angle_min
        scan_msg.angle_max = self.angle_max
        scan_msg.angle_increment = self.angle_increment
        scan_msg.time_increment = 0.0
        scan_msg.scan_time = self.scan_time
        scan_msg.range_min = self.range_min
        scan_msg.range_max = self.range_max

        # determine amount of rays to create
        ranges_size = math.ceil((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment)

        # determine if laserscan rays with no obstacle data will evaluate to infinity or max_range
        if self.use_inf:
            scan_msg.ranges = [float('inf')] * ranges_size
        else:
            scan_msg.ranges = [scan_msg.range_max + self.inf_epsilon] * ranges_size

        for point_cloud in self.last_point_clouds:
            if self.target_frame and scan_msg.header.frame_id != point_cloud.header.frame_id:
                try:
                    # Lookup the transform using tf_buffer with timeout
                    transform = self.tf_buffer.lookup_transform(
                        target_frame=self.target_frame,
                        source_frame=point_cloud.header.frame_id,
                        time=point_cloud.header.stamp,
                        timeout=rclpy.duration.Duration(seconds=1) 
                    )
                    cloud_msg = do_transform_cloud(point_cloud, transform)
                except TransformException as ex:
                    # self.get_logger().error(f"Transform failure: {str(ex)}")
                    continue
            else:
                cloud_msg = point_cloud

            # Iterate through pointcloud
            for point in read_points(cloud_msg, field_names=("x", "y", "z"), skip_nans=True):
                x, y, z = point
                if math.isnan(x) or math.isnan(y) or math.isnan(z):
                    self.get_logger().debug(f"rejected for nan in point({x}, {y}, {z})")
                    continue

                if z > self.max_height or z < self.min_height:
                    self.get_logger().debug(f"rejected for height {z} not in range ({self.min_height}, {self.max_height})")
                    continue

                range_val = math.hypot(x, y)
                if range_val < self.range_min:
                    self.get_logger().debug(
                        f"rejected for range {range_val} below minimum value {self.range_min}. Point: ({x}, {y}, {z})")
                    continue
                if range_val > self.range_max:
                    self.get_logger().debug(
                        f"rejected for range {range_val} above maximum value {self.range_max}. Point: ({x}, {y}, {z})")
                    continue

                angle = math.atan2(y, x)
                if angle < scan_msg.angle_min or angle > scan_msg.angle_max:
                    self.get_logger().debug(
                        f"rejected for angle {angle} not in range ({scan_msg.angle_min}, {scan_msg.angle_max})")
                    continue

                # overwrite range at laserscan ray if new range is smaller
                index = int((angle - scan_msg.angle_min) / scan_msg.angle_increment)
                if range_val < scan_msg.ranges[index]:
                    scan_msg.ranges[index] = range_val

        self.get_logger().info(f'{self.colorize("GO2 Lidar Data Received","green")}', once=True)
        self.pub_scan.publish(scan_msg)
    
    def destroy_node(self):
        self.get_logger().info(f'{self.colorize("GO2 Lidar Publisher is shutting down","red")}')
        super().destroy_node() 

def main(args=None):
    rclpy.init(args=args)
    pointcloud_to_scan = PointCloudToLaserScanNode()
    
    thread_node = threading.Thread(target=rclpy.spin, args=(pointcloud_to_scan, ), daemon=True)
    thread_node.start()

    try:
        while rclpy.ok():
            pointcloud_to_scan.update_scan()
            pointcloud_to_scan.rate.sleep()
    except KeyboardInterrupt:
        pass
    finally:
        pointcloud_to_scan.destroy_node()
        rclpy.shutdown()
        thread_node.join()

if __name__ == '__main__':
    main()